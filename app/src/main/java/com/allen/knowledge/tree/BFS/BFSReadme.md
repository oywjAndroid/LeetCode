#### 1、BFS算法框架详解

广度优先算法（Breadth-First-Search）简称BFS，简单说，从根节点出发沿着树的宽度遍历树的节点，如果发现目标，则演算终止。

深度优先算法（Depth-First-Search）简称DFS，简单说，从根节点出发沿着每一个可能的路径向下搜索，知道不能深入为止，并且每个节点只能访问一次。

其实DFS就是回溯算法。

#### 2、BFS问题的本质

BFS问题的本质：在一幅【图】中找到起点`start`到终点`target`的最短距离。

#### 3、BFS算法框架

```java
int BFS(Node start,Node target){
  Queue<Node> q;//核心数据结构
  Set<Node> visited;//记录已经访问的节点
  
 	q.offer(start);//将起点加入队列
  visited.add(start);
  int step = 0;//记录扩散的步数
  
  while(q not empty){
    int sz = q.size();
    for(int i = 0;i < sz;i++){
      Node cur = q.poll();
      // 重点：这里判断是否到达终点
      if(cur is target){
        return step;
      }
      
      // 将 cur 的相邻节点加入队列
      for(Node x : cur.adj()){
        if(x not in visited){
          q.offer(x);
          visited.add(x);
        }
      }
      
      // 重点：更新步数在这里
      step++;
    }
  }
}
```

`visited`的主要作用是为了防止走回头路，大部分的时候都是必须的，但是想一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要`visited`。

#### 4、BFS算法实践

* 二叉树的最小深度

  题目：给定一个二叉树，找出最小深度，最小深度是从根节点到最近的叶子节点的最短路径上的节点数量。

  说明：叶子节点是没有子节点的节点。

  示例：给定二叉树`[3,9,20,null,null,15,7]`,返回它的最小深度2.

* 打开转盘锁

  题目：你有一个带有四个圆形拨轮的转盘锁，每个拨轮都有10个数字`0~9`，每个拨轮可以自由旋转：例如把‘9’变成‘0’，‘0’变成‘9’。每次旋转都只能旋转一个拨轮的一位数字。

  锁的厨师数字为‘0000’，一个代表四个拨轮的数字字符串。

  列表`deadends`包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。

  字符串`target`代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回-1。

  

  分析问题的方法：

  1. 化繁为简，先不管所有的限制条件，不管`deadends`和`target`的限制，就思考一个问题，如果让你设计一个算法，穷举所有可能的密码组合，你怎么做？

  