#### 动态规划详解

动态规划问题的一般形式就是求最值。

求解动态规划的核心问题是穷举，要求解最值，肯定需要把所有可行的答案穷举出来，然后在其中找最值。

动态规划的穷举有点特别，这类问题存在重叠子问题，如果暴力穷举的话效率会极其低下，所以需要备忘录、DP table来优化穷举过程，避免不必要的计算。

重叠子问题、最优子结构、状态转移方程是动态规划的三要素。

`具有最优子结构，子问题是相互独立的，比如愿问题是考出最高的总成绩，那么你的子问题就是把语文、数学...都考到最高，这就是总成绩最高。`

##### 1、斐波那契数列

​	什么是斐波那契数列？斐波那契数列是指从0和1开始，后续的数都是由前两个数相加得到的数列。换句话说，每个数都是前面两个数的和。斐波那契数列的前几个数字依次为 [ 0、1、1、2、3、5、8、13、21 ] 等。

但凡需要递归的问题，最好都画出递归树，这对分析算法的复杂度，寻找算法低效的原因有巨大的帮助。

通过递归树，我们发现计算斐波那契数列的时候存在许多重复的计算，我们把这类重复计算称为重叠子问题。

* 带备忘录的递归解法：

​		每次算出某个子问题的答案先不急着返回，先记到备忘录里面再返回；

​		每次遇到一个子问题先去备忘录里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。

​		带备忘录的递归解法已经和迭代的动态规划解法一样了，只不过这种方法叫做`自顶向下`，动态规划叫做`自底向上`。

* 自顶向下：从一个规模较大的原问题f(20)，向下逐渐分解规模，知道f(1)和f(2)触底，然后逐层返回答案。

* 自底向上：从最底下，最简单，问题规模最小的 f(1) 和 f(2)开始往上推，直到推到我们想要的答案 f(20)，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。

##### 2、凑零钱问题

​		给你 k 种⾯值的硬币，⾯值分别为 c1, c2 ... ck ，每种硬 币的数量⽆限，再给⼀个总⾦额 amount ，问你**最少**需要⼏枚硬币凑出这个 ⾦额，如果不可能凑出，算法返回 -1 。

* 暴力递归解法

  动态规划问题实际上就是优化暴力递归的解法，通过暴力递归解法与dp table处理掉重叠子问题就能推演出动态规划解法。

  * 1、确定是否存在最优子结构

    为什么说凑零钱问题符合最优子结构呢？比如你要求 amount = 11 时的最少硬币数量，如果你知道凑出 amount = 10 的最少硬币数，只需要把子问题的答案加一就是原问题的答案，因为硬币数量是没有限制的，子问题之间没有相互制约，是相互独立的。

  * 2、确定状态

    状态是原问题和子问题中变化的变量，在凑零钱问题中，由于硬币数量无限，所以唯一的变量就是目标金额 `amount`。

  * 3、确定 dp 函数的定义

    凑零钱问题中，当前的目标金额是n，至少需要 dp(n)个硬币凑出该金额。

  * 4、确定选择并择优

    对于每个状态，可以做出什么选择改变当前状态。

    凑零钱问题中，无论当前的目标金额是多少，选择就是从面额列表 coins 中选择一个硬币，然后目标金额就会减少。

  * 5、确定 base case

    任何能进行递归运算的问题，都存在base case，这是递归回溯的条件，不然递归会无限进行下去。

    凑零钱问题中，显然目标金额为0时，所需硬币数量为0，当目标金额小于0时，无解，返回-1。

  ```java
  
  ```

  

​		