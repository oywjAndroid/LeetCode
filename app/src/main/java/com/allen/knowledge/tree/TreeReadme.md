#### 1、树的基本概念

* 树是一种非线性结构，它兼具了数组查询快，链表增删快的特点。

* 节点

  * 树结构中存储的每个元素叫做节点，根据节点的特殊位置会存在一些不同的叫法

  * 根节点：根节点只有一个，树结构中最上面的节点

  * 父节点、子节点

  * 叶子节点：没有子节点的节点称为叶子节点

  * 子树和空树：单个节点也是一颗树，只不过根节点就是它本身，各个子树之间不能有交集，空树就是没有任何节点的空集合。

  * 节点的度和层次：

    ![树的深度图](https://s2.51cto.com/images/blog/202106/16/d89e7a8ec7d7ce5bb2d7de91ac48817f.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184)

    一个节点拥有的子树数量称为节点的度，树中个节点度的最大值称为树的度。如，图中A节点有BCD三个子树，节点A的度为3，这个树中节点度的最大值是3，因此树的度也是3。	

  * 树的深度：树的深度是树中节点所在的最大的层次，上图树的深度为4

  * 兄弟节点：如果两个节点的父节点虽不相同，但是它们的父节点在同一个层次上，那么这两个节点就是兄弟节点，如：节点G和E、F、H、I、J的父节点都在第二层，所以它们是兄弟节点。

  * 有序树和无序树

#### 2、二叉树（Binary Tree）的特点

* 二叉树的每个节点的度最大为2

* 二叉树的左右节点是有顺序的

  对于二叉树来说，它的左右节点是有序的，不同顺序就不是同一个二叉树。

#### 3、二叉树的分类

* 完全二叉树

  除最后一层外，每一层上的节点数均达到最大值，最最后一层上只缺少右边的若干节点。

  ![完成二叉数](https://book.itheima.net/uploads/course/images/c/3.6/image-20200627125947059.png)

  完全二叉树的特点：

  * 叶子节点只能出现在最下两层
  * 最下层叶子节点一定集中在左边连续位置
  * 如果节点的度为1，那么该节点只有左孩子，不存在只有右孩子的情况
  * 同样节点树的二叉树，完全二叉树的深度最小

* 满二叉树

  除叶子节点外，树中的每个节点都有两个孩子节点，每一层的节点数都达到最大。满二叉树是完全二叉树的一种特殊情况，所以满二叉树也是完全二叉树。

  ![满二叉树](https://book.itheima.net/uploads/course/images/c/3.6/image-20200627130051532.png)

* 斜树

  只有左孩子或者只有右孩子的的树叫做斜树，只有左孩子的二叉树叫做左斜树，只有右孩子的叫做右斜树。

  ![斜树](https://book.itheima.net/uploads/course/images/c/3.6/image-20200627130121605.png)

  斜树的每一层都只有一个节点，节点的个数与二叉树的深度相同。斜树与线性表结构是相同的，其实线性表可以看成是树的一种特殊形式。

#### 4、二叉树的性质

* 二叉树的第 i 层上最多有  `2^(i-1)` 个节点

  ```java
  i = 1, 2^(1-1) = 1个节点
  i = 2, 2^(2-1) = 2个节点
  i = 3, 2^(3-1) = 4个节点
  ...
  i = n, 2^(n-1) 个节点
  ```

  注意：这里计算的是最多的节点。

* 深度为 k 的二叉树最多有 `2^k - 1` 个节点

  ```tex
         A
       /   \
      B     C
     / \   / \
    D   E F   G 
           
  k = 3, 2^3 - 1 = 7，该二叉树最多有7个节点。                
  ```

* 对于任何一个二叉树，如果该树中度为2的节点数是n2，那么叶子节点的数量`n0 = n2 + 1`

  ```
         A
       /   \
      B     C
     / \   / 
    D   E F  
    例1:度为2的节点有A,B，则叶子节点数 = 2 + 1 = 3 ，对应的是 D,E,F
    
         A
       /   \
      B     C
     /    
    D    
    例2:度为2的节点有 A，则叶子节点数 = 1 + 1 = 2，对应的是D,C
  ```

* 具有n个节点的完全二叉树，他的深度为 `log2N + 1`

* 若对完全二叉树中的节点从上到下，从左到右编号，则编号为i (1 <= i <= n)的节点，其左孩子编号为 `2i`，其右孩子编号必为`2i+1`,其双亲编号必为 `i/2`。

  ![完全二叉树的编号规则](https://book.itheima.net/uploads/course/images/c/3.6/image-20200627130212520.png)



#### 5、二叉树的存储结构

* 二叉树的顺序存储

  所谓的二叉树顺序存储就是使用一段连续的存储空间（数组）保存二叉树的逻辑关系。如果我们将完全二叉树按照从上到下，从左到右的顺序编号存储到数组中，按照二叉树的性质5可以完全推断出二叉树的逻辑关系。

  ![完全二叉树的顺序存储](https://book.itheima.net/uploads/course/images/c/3.6/image-20200627130314351.png)

  * 不完全二叉树的顺序存储解决方案

    对于完全二叉树，顺序存储与还原都没有问题，但是一般二叉树，如果依然按照性质5的方式进行排序进行顺序存储，数组元素下表关系将不能反映二叉树的逻辑关系。

    ![一般二叉树的顺序存储](https://book.itheima.net/uploads/course/images/c/3.6/image-20200627130338244.png)

    为了解决一般二叉树的顺序存储问题，可以将二叉树空缺的部分不上空节点，使之成为一个完全二叉树，然后再用一维数组进行存储。

    ![补全二叉树的顺序存储](https://book.itheima.net/uploads/course/images/c/3.6/image-20200627130417605.png)

* 二叉树的链式存储

  二叉树的链式存储是利用链表来实现的，链表中的节点存储树节点中的元素和树节点之间的关系。链表用来存储二叉树有两种常用的方式：二叉表示法、三叉表示法。

  * 二叉链表法

    使用二叉链表表示树，通常树中的每个节点由三个部分构成：数据域、左指针、右指针。左、右指针分别表示节点的左、右孩子

    ![二叉链表的节点](https://book.itheima.net/uploads/course/images/c/3.6/image-20200627130503194.png)

    ```java
    public class TreeNode{
      private Object data;
      private TreeNode lChild;
      private TreeNode rChild;
    }
    ```

    其中数据域data存储节点数据信息，lChild与rChild分别存储指向左孩子与右孩子的指针，当孩子节点不存在时，相应指针要指向空，利用这种节点结构构建出的链式二叉树被称为二叉链表。

    ![二叉链表法](https://book.itheima.net/uploads/course/images/c/3.6/image-20200627130543353.png)

  * 三叉链表法

    二叉链表只能访问孩子节点，而不能访问该节点的父节点，为了能够支持查找父节点，在二叉链表中增加指向父节点的指针parent，形成一个带父指针的节点，使用这种节点构建出来的二叉树称为三叉链表。

    ![三叉链表的节点结构](https://book.itheima.net/uploads/course/images/c/3.6/clip_image002.gif)

    ```java
    public class TreeNode{
      private Object data;
      private TreeNode lChild;
      private TreeNode rChild;
      private TreeNode parent;
    }
    ```

    ![三叉链表示法](https://book.itheima.net/uploads/course/images/c/3.6/image-20200627130725796.png)

  * 双亲表示法

    双亲表示法是另一种存储方法，它利用以为数组来存储树的节点，节点结构总包中包含节点本身信息，也包含父节点信息。

    ![双亲表示法](https://book.itheima.net/uploads/course/images/c/3.6/image-20200627130847867.png)



#### 6、二叉树的遍历

![二叉树示例](https://book.itheima.net/uploads/course/images/c/3.6/image-20200627131009279.png)

* 先序遍历（根左右）

  先序遍历，先访问根节点，然后访问左子树，最后访问右子树，上图的前序遍历结果：ABFLDI。

  先序遍历详细过程：

  * 第一步，访问根节点，输出A；
  * 第二步，访问左子树，左子树以B为根节点的二叉树，如上图虚线圈起来部分，先遍历这个左子树的根节点，输出B；
  * 第三步，访问B的左子树，发现没有左子树，则访问B的右子树，右子树是以F为根节点的二叉树，遍历这个二叉树的根节点，输出F；
  * 第四步，访问F的左子树，左子树是以L为节点的二叉树，遍历这颗树的根节点，输出L；
  * 第五步，访问L的左子树，L没有左子树，则访问L的右子树，L没有右子树，那么以L为根节点的二叉树访问完毕，即F的左子树访问完毕；
  * 第六步，访问F的右子树，F没有右子树，则以F为根节点的二叉树访问完毕，即B的右子树访问完毕，那么以B为根节点的二叉树访问完毕，即A的左子树访问完毕；
  * 第七步，访问A的右子树，右子树是以D为根节点的二叉树，则先访问根节点，输出D；
  * 第八步，访问D的左子树，D的左子树是以I为根节点的二叉树，则先访问根节点，输出I；
  * 第九步，访问I的左子树，I没有左子树，访问I的右子树，I没有右子树，那么以I为根节点的二叉树访问完毕；
  * 第十步，访问D的右子树，D没有右子树，那么以D为根节点的二叉树访问完毕，即A的右子树遍历完毕，整颗树也遍历完毕。

* 中序遍历（左根右）

  中序遍历，先访问左子树，然后访问根节点，最后访问右子树，上图的中序遍历结果：BLFAID。

  中序遍历的详细过程：

  * 第一步，先访问根节点A的左子树，左子树是以B为根节点的二叉树，先访问B的左子树，B没有左子树，则访问根节点B，输出B；
  * 第二步，访问B的右子树，右子树是以F为根节点的二叉树；
  * 第三步，访问F的左子树，F的左子树是以L为根节点的二叉树；
  * 第四步，访问L的左子树，L没有左子树，访问L的根节点，输出L；
  * 第五步，访问L的右子树，L没有右子树，以L为根节点的二叉树访问完毕，那么F的左子树访问完毕，访问F的根节点，输出F；
  * 第六步，访问F的右子树，F没有右子树，以F为根节点的二叉树访问完毕，即B的右子树遍历完毕，以B为根节点的二叉树也访问完毕；
  * 第七步，访问根节点，输出A；
  * 第八步，访问A的右子树，A的右子树是以D为根节点的二叉树；
  * 第九步，访问D的左子树，D的左子树是以I为根节点的二叉树；
  * 第十步，访问I的左子树，左子树不存在，访问根节点I，输出I；
  * 第十一步，访问I的右子树，右子树不存在，那么以I为根节点的二叉树访问完毕，即D的左子树访问完毕，访问根节点D，输出D；
  * 第十二步，访问D的右子树，右子树不存在，那么以D为根节点的二叉树访问完毕，即A的右子树访问完毕，整颗树反问完毕。

* 后序遍历（左右根）

  后续遍历，先访问左子树，然后访问右子树，最后访问根节点，上图的后序遍历：LFBIDA。

  后续遍历的详细过程，与前、中序遍历类似，这里不再赘述。

#### 7、递归思想的应用

二叉树的遍历是树结构插入、修改、删除、查找和排序的前提，是二叉树一切运算的基础和核心。而遍历中涉及到的递归思想，几乎在树的所有操作都有体现。

* 求二叉树叶子节点的个数

  用任何一种遍历算法遍历二叉树，凡是书中节点左右指针都为空者就是叶子节点，算法思想如下：

  * 二叉树的叶子节点个数就是左子树叶子节点和右子树叶子节点个数之和；
  * 左子树又可视为一棵独立的二叉树，它的叶子节点个数是其左子树和右子树叶子节点之和；
  * 右子树又可视为一个独立的二叉树，它的叶子节点个数是其左子树和右子树叶子节点树之和；

  这样不断递归，直到二叉树遍历完毕，就可算出叶子节点的个数。

* 求二叉树的高度

  在二叉树中，根节点是树中的第一层，求其左子树和右子树的高度，比较左右子树的高度，取较大的值加上根节点的高度1就是整个树的高度。

* 拷贝二叉树

  拷贝二叉树需要逐个的拷贝书中的节点，不管树又多么复杂，都可以分为三个部分：根节点、左子树、右子树。

  拷贝是分以下3个步骤来完成拷贝：

  * 为新树分配新的根节点
  * 先拷贝左子树，在拷贝右子树，新根节点的左孩子指针指向拷贝过来的左子树，右孩子指针指向拷贝过来的右子树
  * 如果左右子树是一棵树，重复以上步骤。

#### 8、二叉树遍历的实质

首先思考以下三个问题：

* 你理解的二叉树的前中后序遍历是什么，仅仅是三个顺序不同的List吗？
* 请分析，后序遍历有什么特殊之处？
* 请分析，为什么多叉树没有中序遍历？

```java
void traveerse(TreeNode root){
  if(root == null){
    return;
  }
  // 前序位置
  traverse(root.left);
  // 中序位置
  traverse(root.right);
  // 后序位置
}
```

注意，递归的本质是函数不断压栈、出栈的过程。

![递归过程产生的特殊时间点](https://labuladong.github.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e6%94%b6%e5%ae%98/1.jpeg)

所谓的前置位置，就是刚进入一个节点的时候，后序位置就是即将离开这个节点的时候，我们平常大多看到的是前中后序位置的结果，可能大部分人都认为那只是三种不同顺序的结果。现在我们使用上述 `traverse()`遍历函数数据的打印，我们分别在三个位置进行数据打印，看看最终得到的记过是什么。

```java
// 1.在前序位置执行打印，发现结果就是前序遍历的结果
void traveerse(TreeNode root){
  if(root == null){
    return;
  }
  // 前序位置
  System.out.println(root.getData());
  traverse(root.left);
  // 中序位置
  traverse(root.right);
  // 后序位置
}

// 2.在中序位置执行打印，发现结果就是中序遍历的结果
void traveerse(TreeNode root){
  if(root == null){
    return;
  }
  // 前序位置
  traverse(root.left);
  // 中序位置
  System.out.println(root.getData());
  traverse(root.right);
  // 后序位置
}

// 3.在后序位置执行打印，发现结果就是后序遍历的结果
void traveerse(TreeNode root){
  if(root == null){
    return;
  }
  // 前序位置
  traverse(root.left);
  // 中序位置
  traverse(root.right);
  // 后序位置
  System.out.println(root.getData());
}
```

`总结，前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点。`

为什么多叉树没有中序位置，因为二叉树的每个节点都会进行唯一一次左子树切换右子树，而多叉树节点可能有很多子节点，会多次切换子树去遍历，所以多叉树的没有唯一的中序遍历位置。



